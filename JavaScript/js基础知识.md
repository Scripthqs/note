### JavaScript的书写位置
HTML中推荐双引号，js中推荐单引号。js严格区分大小写。分号结尾但是可以省略。
有3种方式引入js代码：
- 行内式：直接写HTML标签的事件中
- 内嵌式：直接编写到`<script>`标签中。
- 引入外部JS文件`<script src="tool.js"></script>`

### JavaScript输入输出语句
- 弹出警告框 `alert()`
- 控制台输出 `console.log()`
- 向body中输入内容 `document.write()`
- 弹出输入框 `prompt()`，用户不管输入什么内容，都是字符串。我们可以用一个变量，来接收用户输入的内容。

### 字面量和变量

#### 字面量
字面量即常量，不可改变的量。
- 数字 12345
- 字符串 单词句子'123' 'word' '吃饭'
- 布尔值 true false 

字面量都可以直接使用，但是我们都不会直接使用字面量。一般定义一个变量来保存这个字面量。

#### 变量
变量是程序向内存申请的一块可以存储数据的空间。变量需要的声明和赋值。
- 声明/定义变量 
  - `var name;`声明一个名为`name`的变量。ES6之前都用`var`
  - `const name;` 定义一个常量
  - `let age;` 定义一个变量

- 变量的赋值
  - `name = 'haha'` 变量名=变量值

变量的声明和赋值可以写在一起。
- var a = 100;
- const b = hello
- let b = world

声明一个变量并赋值，称为变量的初始化。

声明变量要点：
- 变量新赋值，以最后一次赋值为准
- 同时声明多个变量，多个变量名用`,`隔开。var name = 'a' , age =18;
- 变量建议先声明再使用。
- 变量名严格区分大小写。
- 定义但为赋值的变量结果显示`undefined`

### 区块
JavaScript使用大括号，将多个语句组合起来，称为区块。对于`var`命令，JavaScript的区块不构成单独的作用域（scope）。
````js
{
    var a = 1;
}
a
````
在区块内部，使用var声明并赋值的变量a，在区块外部依然有效。区块对于var不构成单独的作用域。



### 标识符、关键字、保留字

#### 标识符
标识符：在js中可以由我们自主命名的都可以成为标识符。

变量名、函数名、属性名、参数名都是标识符。我们写代码时取得名字就是标识符。
- 可以含有字母、数字、`_`、`$`
- 不能以数字开头
- 不能是关键字和保留字
- 一般使用驼峰命名法，首字母小写，每个单词开头大写，`helloWorld` `tuoFengMingFa`
- 或者下划线方法`hello_world`


#### 关键字
JS本身已经使用得单词，不能再用来充当变量。
#### 保留字
预备关键字

### 变量的数据类型
在计算机中，不同的数据所需的存储空间不同，为了充分利用存储空间，就定义了不同的数据类型。js中一共有6种数据类型，5种基本数据类型（值类型），1种引用数据类型（引用类型）。
- `String` 字符串
- `Number` 数值
- `Boolean` 布尔值
- `Null` 空值
- `Undefined` 未定义
- `Object` 对象

变量的数据类型是可以变化的，`var name = 'a'; name = 1;` 此时，变量name由字符串变成了数字类型。

基本数据类型和引用数据类型的最大区别：
- 基本数据类型：参数赋值时，传数值。
- 引用数据类型：参数赋值时，传地址。

引用数据类型只有1种，但是可以分为3个子类型
- 狭义的对象 object
- 数组 array
- 函数 function

### 栈内存和堆内存
JS中，所有的变量都保存在**栈内存**中的。

#### 基本数据类型
基本数据类型的值，直接保存在**栈内存**中。值和值相互独立，修改一个变量不会影响其他变量。

#### 引用数据类型
对象是保存在**堆内存**中的，每创建一个新的对象，就会在堆内存中开辟一个新的空间；而变量保存了对象的内存地址（对象的引用），保存在栈内存中。如果两个变量保存了同一对象的引用，当一个通过一个变量修改属性时，另一个也会受到影响。
- 对象的值是保存在堆内存中的，而对象的引用（即变量）是保存在栈内存中的。

### typeof 运算符
JavaScript有3种方法确定值到底是什么类型。
- typeof 运算符
- instanceof 运算符
- Object.prototype.toString 方法

`typepf`运算符可以返回一个值的数据类型。它会将该值的类型以字符串的形式返回。
````js
// 写法1
typeof 变量;

// 写法2
typeof(变量);
````
- 数值返回 `'number'`
- 字符串返回 `'string'`
- 布尔值返回 `'boolean'`
- 函数返回 `'function'`
- undefined返回 `'undefined'`
- null返回 `'object'` 特殊，因为在1995年时，没有考虑null，把null当作object的特殊值。

`typeof`可以用来检查一个没有声明的变量，而不报错。
````js
v
// ReferenceError: v is not defined
typeof v
// "undefined"
````
变量v没有用var命令声明，直接使用就会报错。但是，放在typeof后面，就不报错了，而是返回undefined。



### String字符串
字符串使用单引号或者双引号。要点：
- `''`引号间什么都不写，称为空字符串。
- 同类引号不能嵌套。
- 对于一些特殊的符号，可以使用`\`作为转义字符。
  - `\'` 单引号
  - ` \"` 双引号
  - `\n` 换行
  - `\r`回车
  - `\b`空格
  
#### 获取字符串的长度
字符串由若干份字符串组成，这些字符的数量就是字符串的长度，可以通过length属性获取整个字符串的长度。
````js
        var str1 = '你好';
        var str2 = 'hello';
        var str3 = 'hello world';
        var str4 = 'hello,world';
        console.log(str1.length); // 2
        console.log(str2.length); // 5
        console.log(str3.length); // 11
        console.log(str4.length); // 11
````
- 一个中文、英文都算一个字符
- 一个中文标点、英文标点算一个字符
- 一个空格算一个字符，多个连续空格也算多个字符。

#### 字符串的拼接
多个字符串之间可以使用加号 `+` 进行拼接。

`字符串 + 任意数据类型 = 拼接之后的新字符串`

拼接前，任意数据类型会强制转换成字符串，然后再拼接成一个新的字符串。应用：
- `''+任意数据类型` 可以强制转换成字符串

#### 字符串与数组
- 字符串可以视为字符数组，因此可以使用方括号运算符，用来返回某个位置的字符，从0开始。
````js
        var s = 'hello';
        console.log(s[0])// "h"
        console.log(s[1])// "e"
        console.log(s[4])// "o"
        // 直接对字符串使用方括号运算符
        console.log('hello'[1]) // "e"
````
- 如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。
- 字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。

#### 字符串的不可改变性
字符串里面的值不可被改变，虽然看上去内容变了，其实是地址变了，内存中开辟了新的空间。 
````js
var str = 'hello';
str = 'world';
````
当重新给变量str赋值时，常量'hello'不会被修改，依然保存在内存中，str会改为指向`world`。

#### 模板字符串（模板字面量）
````js
          var name = 'tom';
          var age = '17';
          console.log('我是' + name + ',age:' + age);//传统写法
          console.log(`我是${name},age:${age}`);//ES6新语法
````
注意：ES6新语法括号中不是单引号，而是TAB键上方的符号。

- 模板字符串中可以直接换行
````js
          var name = 'tom';
          var age = '17';
          console.log(`我是${name},
          age:${age}`);//ES6新语法
````
- 在模板字符串中插入表达式
````js
          var a = 2;
          var b = 1;
          console.log(`和为${a+b}，积为${a*b}`);//ES6新语法
````
- 模板字符串中可以调用函数
- 模板字符串支持嵌套使用

### Number数值
JS中所有的数值都是Number类型，包括整数和浮点数（小数）。JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数），1与1.0是相同的，是同一个数。JavaScript 内部实际上存在2个0：一个是+0，一个是-0，区别就是64位浮点数表示法的符号位不同。它们是等价的。但是，当+0或-0当作分母，返回的值是不相等的。因为除以正零得到+Infinity，除以负零得到-Infinity，这两者是不相等的。


- 精度最多只能到53个二进制位，绝对值小于2的53次方的整数，即-2^53到2^53,都可以精确表示。
- 能够表示的数值范围为2^1024到2^-1023（开区间），超出这个范围的数无法表示。
- JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。

当Number表示的变量超过了最大值，则会返回infinity。
- 正无穷 infinity 
  - Infinity与null计算时，null会转成0，等同于与0的计算。
  - Infinity与undefined计算，返回的都是NaN。
- 负无穷 -infinity
- 特殊的数字 NaN not a number，非数值。NaN在布尔运算时被当作false。
- 这三个值使用typeof的结果都是Number。

NaN与任何值都不相等，包括NaN本身，Undefined和任何数值计算的结果都是NaN。

`+`只有在两边都是Number类型时，才是数字相加，否则就是连字符，用来连接字符串。

`-`时，"2"-1得到的结果却是数值1，字符串会自动做隐式转换。

#### 数字进制
- 十进制：没有前导0的数值。
- 八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。
- 十六进制：有前缀0x或0X的数值。
- 二进制：有前缀0b或0B的数值


#### 运算精度
JS中整数运算基本可以保证准确，小数运算很可能得到一个不准确的结果。要进行准确的运算的方法；
- 简单精度 使用`toFix()`方法进行小数的截取
- 实际开发中，可以使用数学运算开源库
  - Math.js 文件很大，压缩的文件500kb，涉及大型的复杂运算使用
  - decimal.js 轻量的运算库，压缩的文件32kb，大多数数学运算项目都可以满足。

开源库既可以使用cdn的方式引用，也可以使用npm包的方式引入。

#### 关于数值相关的全局方法
1.  parseInt()将字符串转换成整数
  - 头部空格会自动消除
  - 不是字符串，则会先转为字符串再转换
  - 第一个字符不能转换成数字（除后面直接跟着数字的正负号），返回NaN。
  - 返回值只有两种可能，十进制整数或者NaN。
  - 字符串以0x或0X开头，parseInt会将其按照十六进制数解析
  - 如果字符串以0开头，将其按照10进制解析或者8进制。
  - 科学计数法不好使，e会被当成普通字母。
````js
          parseInt(1000000000000000000000.5) // 1
          // 等同于
          parseInt('1e+21') // 1
          parseInt(0.0000008) // 8
          // 等同于
          parseInt('8e-7') // 8
````
  - parseInt方法还可以接受第二个参数（2到36之间，如果第二个参数没有意思则会被忽略），表示被解析的值的进制。默认值是10。
````js
          parseInt('1000', 2) // 8
          parseInt('1000', 6) // 216
          parseInt('1000', 8) // 512
````

2. parseFloat()将一个字符串转为浮点数。
   - 科学计数法好使。
   - 空字符串转为NaN。

3. isNaN()方法可以用来判断一个值是否为NaN。
   - 只对数值有效，如果传入其他值，会被先转成数值。
   - isNaN为true的值，有可能不是NaN，而是一个字符串。
   - 对于对象和数组，isNaN也返回true。
   - 但是对于空数组和只有一个数值成员的数组，isNaN又返回false。
   - NaN是唯一不等于自身的值，这是最可靠的方法。
````js
          function myIsNaN(value) {
            return value !== value;
          }
````
4. isFinite()方法返回一个布尔值，表示某个值是否为正常的数值。
   - Infinity、-Infinity、NaN和undefined这几个值会返回false
   - `isFinite`对于其他的数值都会返回true。


### Boolean布尔值
布尔值有两个`true` 和 `false`。千万不能加引号，主要用来做逻辑判断： 
- true 表示真
- false 表示假

布尔型和数字型相加时，
- true 按 1 来算 
- false 按 0 来算
对于以下几个值转换成布尔值时为false，其他都是true。
- undefined
- null
- false
- 0
- NaN
- ""或'' 空字符串

注意：空数组（[]）和空对象（{}）对应的布尔值，都是true。

### Null和Undefined
null专门用来定义空对象，如果想定义一个变量引用类型，但是暂时还没想好放什么内容，可以设置为null。
- Null类型的值只有一个，就是null。
- 使用typeof检查一个null值时，会返回object。

undefined未定义，使用的情况：
- 变量已声明，但未赋值，此时该变量的值就是undefined
- 变量未声明未定义时，直接使用会报错，使用typeof检查则返回undefined。
- 如果一个函数没有返回值，那么，这个函数的返回值就是 undefined。在定义一个函数时，如果末尾没有return语句，那么其实就是`return undefined`
- 调用函数时，如果没有传参，那么这个值就是undefined。

#### null和undefined的区别
- null == undefined 为true
- null === undefined 为false
- 和数字做运算时：
  - 10 + null 结果时10
  - 10 + undefined 结果为NaN

任何数据类型和undefined运算都是NaN，任何值和null运算都相当于和0运算。


### 强制的类型转换
将一个数据类型强制转换成其它的数据类型。类型转换主要指将其他的数据类型转换为String Number Boolean。

#### 将其他数据类型转换成String
- 调用被转换数据类型的toString()方法。
  - 该方法不会影响原变量，它会将转换的结果返回
  - 调用xxx的yyy方法，就是xxx.yyy
  - `var a = a.toString();`
  - 注意：null和undefined两者值没有toString()方法。
- 调用String()函数，并将转换的数据作为参数传递给函数。
  - 调用xxx函数，就是xxx();
  - `var a = String(a);`
  - 使用String()函数做强制转换时，对于Number和Boolean实际上就是调用的toString()方法，对于Null和Undefined则是直接转换成"Null"和"Undefined"

#### 将其他数据类型转换成Number
- 调用Number()函数，并将转换的数据作为参数传递给函数。
  - `var b = Number(b);`
  - 纯数字字符串转换成数字
  - 含有非数字内容转换成NaN
  - 空串和全空格转换成0
  - 布尔值true转换成1，false转换成0
  - null转换成0，undefined转换成NaN
- parseInt()将一个字符串转换成整数，专门处理字符串
  - 可以将一个字符串的有效整数取出来
  - `var c = parseInt(c);`
- parseFloat()将一个字符串转换成小数
  - 可以将一个字符串的有效小数取出来，专门处理字符串
  - `var c = parseInt(c);`
- parseInt()和parseFloat()会将非字符串会先转换字符串再操作。

#### 将其他数据类型转换成Boolean
- 使用Boolean()函数，并将转换的数据类型作为参数传递给函数。
  - `var d = Boolean(d);`
  - Number类型中，除了0和NaN，其余的都是true
  - String中，除了空串`''`，其余的都是true
  - null和undefined都会转换成false
  - 对象也会转换成true

### 隐私类型转换
- 任意数据类型和String`+`时，结果会变成字符串拼接。
  - `var a = a + ''`
  - 加上一个空字符串`''`，即可将a转换成字符串，这个方法等价于`var a = String(a);`
- 任意数据类型和Number`-` 、`*`、`/`都会转换成Number。
  - `var b = b - 0`、`var b = b * 1`、`var b = b / 1`
  - 更简单的写法 `var b = +b`
- 任意数据类型做两次非运算即可转换成Boolean
  - `var c = !!c`


### 自增自减
- `a++`和`++a`
  - 无论是哪一种都会使原变量自增1
  - 不同的是`a++`和`a++`的值不同，`a++`的是原值，`++a`是新值
````js
var a = 1;
a = a++;//a=1
a = ++a;//a=2
````
- `a--`和`--a`
  - 无论是哪一种都会使原变量自减1
  - 不同的是`a--`和`--a`的值不同，`a--`的是原则，`--a`是新值

### 逻辑运算符
- `!`非 取反
- `&&`与 全1出1，有0出0
  - `a&&alert('我出不出来')`
  - 如果第一个值为`false`则不再看第二个值，此时alert()语句将不会输出
  - `a&&b`
  - 如果两个值都是`true`，则返回后面一个

- `||`或 有1出1，全0出0
  - `b||alert('我出不出来')`
  - 如果第一个值为`true`则不再看第二个值，此时alert()语句将不会输出
  - 如果两个值都是`false`，则返回后面一个

### 关系运算符
- `>`或者`<`，关系成立则返回`true`，不成立则返回`false`
- 对于非数值的关系运算，会将其转换成数字
- `NaN`和任何值比较都是NaN
- 如果符号两侧的值都是字符串，不会将其转换成数字进行比较，而是分别比较字符串的字符的Unicode编码
- 比较字符编码的是一位一位的比较，如果两位一样则比较下一位
  - 这种方法可以用作字母排序
- 比较两个字符串型的数字时，一定要转型
- `\uxxxx`转义字符`\u`表示Unicode编码
- '=='相等运算符会做类型转换
  - `null==0`是false
  - `null==undefined`是true
  - NaN不和任何值相等，包括它本身

### 条件运算符
条件运算符，又称三元运算符，`条件表达式?语句1:语句2;`
- 条件表达式为true，执行语句1
- 条件表达式为false，执行语句2
- `a>b?a:b`获取a、b中的较大值
- 如果条件表达式不是布尔值，则会先准换成布尔值

### 运算符优先级
- `,`运算符可以分割多个语句，同时声明多个变量
  - `var a,b,c;` `var a=1,b=2,c=3;`
- 与`&&`的优先级比`||`高
  - `1||2&&3`结果为1
- 遇到优先级拿不准的直接加括号`()`

### 语句和代码块
语句(statement)，在J中可以使用`{}`将语句分组，同一个`{}`中的语句称为代码块，里面的内容要么都执行，要么都不执行，结尾不用编写分号。
- JS中的代码块只有分组的作用，代码块中的内容，在外部是完全可见的。

### 流程控制语句
语句有3种结构：
- 顺序结构
- 选择结构 if语句、switch语句
- 循环结构 while语句、for语句

语句有三种：
- 条件判断语句 条件成立才执行
- 条件分支语句
- 循环语句


### if语句
- 语法1：
````js
        if(条件表达式){
          语句;//条件表达式为true，执行
        }
````
- 语法2：
````js
        if(条件表达式){
          语句1;
        }else{
          语句2;
        }
````

````js
        if(条件表达式1){
          语句1；
        }else if(条件表达式2){
          语句2；
        }else{
          语句3；
        }
````

从上到下依次判断，一旦出现条件表达式为`true`的情况，直接结束if语句，不管后面的条件表达式。

### switch语句
- 语法：
````js
        switch(条件表达式){
          case 值1:
            语句1;
            break;
          case 值2:
            语句2;
            break;
            ···
            ···
          default:
            语句n;
            break;
        }
````
计算出表达式的值，和case依次全等比较，比较结果为true，则从当前case处执行代码。
````js
        var m = +prompt('请输入分数');
        switch(true){
            case m >= 60: 
                console.log('合格')
                break;
            default:
                console.log('不合格');
                break;
        }
````
js独有的方式，case后面可以跟表达式。


### while语句
- 语法：
````js    
        while(条件表达式){
          语句···
        }
````
执行流程：
先对条件表达式进行求值判断：
- 值为true，则执行循环体
- 循环体执行完毕后，继续对表达式进行判断
  - 如果为true，则继续执行循环体
  - 直到值false，如果没有则陷入`死循环`
- 如果有必要，可以使用break来终止循环

创建一个循环往往需要3个步骤：
- 初始化一个变量
- 在循环中设置一个条件表达式
- 定义一个更新表达式，每次更新初始化变量
````js
         var n=1;//初始化一个变量
        while(n<10){//条件表达式
            console.log(n);
            n++;//更新表达式
        }
````

do...while语句和while语句的区别；
- do...while语句先执行后判断
- while语句先判断后执行


### for语句
- 语法
````js
        for(初始化表达式;条件表达式;更新表达式){
          语句···
        }
````
执行流程：
- 执行初始化表达式，初始化变量，初始化表达式只会执行一次
- 执行条件表达式，判断是否执行循环
  - 值为true，则执行循环
  - 值为false，终止循环，此时语句将不再执行
- 执行更新表达式，更新表达式执行完毕后，继续执行条件表达式，判断是否继续循环

for循环的三个表达式都可以省略，也可以写在外部。
- 如果不写任何表达式，只写两个`;;`，代表死循环
````js
        for(;;){
          语句···//死循环
        }
````
利用parseInt()方法或者Math.floor()取三位数的各位：
- 百位：`parseInt(i/100)`
- 十位：`parseInt(i%100/10)`或者 `parseInt((i-百位*100)/10)`
- 个位：`i%10`


关于取多位数各位数的规律，多位数除以`/`和取余的效果`%`:
- `/10`  会去除个位
- `/100` 会去除十位及以下
- 依次类推
- `%10` 会留下个位
- `%100` 会留下十位及以下，如果只留下了一位数，代表这个多位数十位必然是0

总结：`/`是去除，`%`是留下。

#### for嵌套
````js
        for( var i = 1; i <= 5; i++){
            for(var j = 1; j <= 5; j++){
                document.write("* &nbsp;")
            }
            document.write("<br/>")
        }
````
- 5行5列的*
- 外层的参数`i`会影响高度，列数
- 内层的参数`j`会影响宽度，行数

打印1-100间的质数
````js
        for (i = 2; i <= 100; i++) {
            var f = true;
            for (j = 2; j < i; j++) {
                if (i % j == 0) {
                    f = false;
                }
            }
            if (f) {
                console.log(i);
            }
        }
````

### break 和 continue
- `if语句`不能使用`break`和`continue`，否则会报错。
- `break`关键字可以退出switch语句或者循环语句(循环语句包括for循环、while循环、不包括if)
- `break`会立即终止离他最近的那个循环语句
- 可以为循环语句创建一个label，`lable:循环语句`，来标识当前循环，可以在 break 后跟着一个 label，这样 break 将会结束指定的循环，而不是最近的。
````js
        for (var i = 0; i < 5; i++) {
            if (i == 2) {
                break; // 注意，虽然在 if 里 使用了 break，但这里的 break 是服务于外面的 for 循环。
            }
            console.log('i的值:' + i);
        }
````
````js
        outer: for (var i = 0; i < 5; i++) {//创建一个label
            console.log('外层循环 i 的值：' + i);
            for (var j = 0; j < 5; j++) {
                break outer; // 直接跳出outer所在的外层循环（这个outer是我自定义的label）
                console.log('内层循环 j 的值:' + j);
            }
        }
````

- `continue`可以用来跳过当次循环，继续下次循环
- `continue`默认只会对离他最近的循环起作用
- 如果需要跳过指定的当次循环，可以使用lable标签
````js
        for (var i = 0; i < 5; i++) {
            if (i == 2) {
                continue; 
            }
            console.log('i的值:' + i);
        }
````

### 测试代码的执行时间
- `console.time('计时器名字')`可以用来开启一个计时器，需要一个字符串作为参数，这个字符串会作为计时器的标识。
- `console.timeEnd('计时器名字')`可以用来停止一个计时器，需要一个字符串作为参数，这个字符串会作为计时器的标识。
- `Math.sqrt()`可以对一个数进行开方。

### 对象
- 只要不是那五种基本数据类型，就全都是对象。
- 对象是一组无序的相关属性和方法的集合。
- 对象的作用的封装信息。比如Student类里可以封装学生的姓名、年龄和成绩。
- 对象具有特征（属性）和行为（方法)。
- 简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。

#### 面向对象
- 面向对象：可以创建自定义的类型，很好的支持继承和多态。
- 面向对象的特征：封装、继承、多态。

#### 对象的分类
- 内建对象
  - 由ES标准中定义的对象，在任何的ES实现中都可以使用。
  - 比如：Object、Math、Date、String、Array、Number、Boolean、Function等。
- 宿主对象
  - 由JS运行环境提供的对象，目前来讲主要是浏览器提供的对象。
  - 比如BOM DOM，比如：`console`、`document`
- 自定义对象
  - 由开发人员自己创建的对象
  - 通过new关键字创建出来的对象实例，都是属于对象的类型。

#### 创建对象
- `var obj = new Object();`
- 使用new关键字调用的函数，是构造函数constructor。
- 构造函数时专门用来创建对象的函数。

使用对象字面量来创建对象：
- `var obj = {};`

添加属性
- `对象.属性名 = 属性值;`

删除属性
- `delete 对象.属性名;`

如果使用特殊的属性名，不能采用`.`的形式来操作，而需要
- `对象['属性名'] = 属性值`
- 读取也需要同样的方式
- 使用这种方式操作属性更加灵活，`[]`间可以直接传递一个变量

#### in运算符
in运算符可以检查一个对象中是否含有指定的属性。
- `'属性名' in 对象`
- 有则返回true
- 无则返回false

#### 基本数据类型和应用数据类型的重点
````js
var obj = new Object();//对象的引用
obj.name = 'haha';
````
- JS中，所有的变量都保存在**栈内存**中的。
- 基本数据类型的值，直接保存在**栈内存**中。值和值相互独立，修改一个变量不会影响其他变量。
- 对象是保存到**堆内存**中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间（这个空间会有一个内存地址）。变量保存的是对象的内存地址（对象的引用）。
- 对象的**值是保存在堆内存**中的，而对象的**引用（即变量）是保存在栈内存**中的。
- 如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响。
- 对象比较是比内存地址。

#### 对象字面量
以构造函数的形式创建对象
- `var obj = new Object();`
- obj.name = 'aaa';
使用对象字面量来创建对象：
- `var obj = {};`

使用对象字面量创建对象时，可以直接指定对象中的属性：
````js
var obj = {
  name:'a',
  age:25,
  gender:'男'
}
````

#### 键值对、属性、方法
````js
        var obj = {
          foo: 'Hello',
          bar: 'World'
          test: {
            name:'a',
            age:12
          }
        };
````
代码分析：
- 1个`{}`就定义了一个对象，赋值给变量`obj`，所以`obj`就指向一个对象.
- 内部包括两个键值对（或者说两个成员），`键名:'键值'`，多个键值对用`,`隔开。
    - CSS的属性语法：`属性：属性值;` 多个属性之间用`;`隔开，多个属性值用`,`隔开。`width:800px;`
    - HTML的属性语法：`属性="属性值"` 多个属性之间用**空格**隔开。`<font color="red" size="3">文字</font>`  
- 键名都是字符串，但是可以不加`''`，如果键名是数值，自动转为字符串。
- 不过，对于不符合标识符的键名，必须要加`''`。
- 对象的每一个键名又称**属性(property)**，它的键值可以是任何数据类型。
- 当键值是函数时，通常把这个属性称为**方法**。
- 当键值时对象时，就会形成链式引用。
- 属性可以动态创建，不必在对象声明时就指定。

#### 对象和代码块
`{ foo: 123 }`可能会有两种含义，对象或者代码块。
- 如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块。
- 如果要解释为对象，最好在大括号前加上圆括号。
````js
({ foo: 123 }) // 正确
({ console.log(123) }) // 报错
````

### 函数
- 函数也是对象
- 函数中可以封装一些功能（代码），在需要时可以只写这些功能和代码
- 可以将要封装的的代码以**字符串的形式**传递给构造函数
- 封装的代码不会立即执行
- 函数代码会在函数调用的时候执行，
- 所有的函数，都是 Fuction 的“实例”（或者说是“实例对象”）。函数本质上都是通过 new Function 得到的。
- 函数既然是实例对象，那么，函数也属于“对象”。

#### 创建函数对象
1. 以构造函数的方式创建函数：
- `var fun = new Function();` 
- 实际开发中，不会使用这种方式

2. 使用函数声明来创建函数：
````js
        function 函数名([形参1,形参2...形参N]){  
          语句...
        }
````
````js
        function fun1(a, b){
          return a+b;
        }
````

- 备注：语法中的中括号，表示“可选”

3. 函数表达式（匿名函数）
````js
        var 变量名  = function([形参1,形参2...形参N]){
          语句....
        }
````
````js
        var fun2 = function() {
          console.log("我是匿名函数中封装的代码");
        };
````

#### 函数的调用
-  普通函数的调用，语法：`函数();`或者`函数名.call();`。
- 通过对象的方法来调用，如果一个函数是作为一个对象的属性保存，那么，我们称这个函数是这个对象的方法。`obj.fn2(); // 调用函数`
- 立即执行函数
````js
        (function (){
            console.log('匿名函数')
        })();
````
- 通过构造函数来调用
- 绑定事件函数
- 定时器函数
````js
    let num = 1;
   setInterval(function () {
       num ++;
       console.log(num);
   }, 1000);
````

#### 形参和实参
形参：
- 形式上的参数。定义函数时传递的参数，当时并不知道是什么值。
- 定义函数时，可以在函数的()中来指定一个或多个形参。
- 多个形参之间使用,隔开，声明形参就相当于在函数内部声明了对应的变量，但是并不赋值。

实参：
- 概念：实际上的参数。调用函数时传递的参数，实参将会传递给函数中对应的形参。
- 在调用函数时，可以在函数的 ()中指定实参。
- 实际参数和形式参数的个数，一般要相同。
- 如果实参的数量少于形参的数量，多余的形参会被定义为 `undefined`
- 如果实参的数量多余形参的数量，多余实参不会被赋值。
- 实参可以是任意数据类型，当需要传递的实参过多时，可以封装到对象中传递。

在 JS 中，形参的默认值是 `undefined`。

#### 函数的返回值
- 可以使用return来设置函数的返回值，语法：`return 值;`
- `return`后的值将作为函数的执行结果返回
- 定义一个变量来接收该结果
- 在函数中，`return`后的语句都不再执行
- 如果函数中不写return或者return后面不写值，都返回`undefined`
- 返回值可以是任意的数据类型
- `return` 只能返回一个值。如果用逗号隔开多个值，则以最后一个为准


  
#### 枚举对象中的属性
for...in语句，对象中有几个属性，循环体就会执行几次，每次执行时，会将对象中的属性的名字赋值给变量。
````js
        for(var n in obj){
            console.log(`属性名${n}`);
            console.log(`属性值${obj[n]}`);
        }
````

#### 作用域
作用域指一个变量作用的范围，在JS中有两种作用域：
- 全局作用域
  - 直接编写到script标签中的JS代码，都在全局作用域
  - 全局作用域在页面打开时创建，关闭时销毁
  - 在全局作用域中有一个全局对象window，代表浏览器的窗口，由浏览器创建，我们可以直接使用
  - 在全局作用域中，我们创建的变量都会作为window对象的属性保存
  - 创建的函数会作为window对象的方法保存
  - 全局作用域中的变量都是全局变量，在页面的任意部分都可以访问

- 函数作用域
  - 调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁
  - 每调用一次函数就会创建一个新的作用域，他们是相互独立的
  - 在函数作用域中可以访问到全局作用域的变量
  - 全局作用域无法访问到函数作用域的变量
  - 当在函数作用域中操作变量时，会先在自身作用域中寻找，有就直接使用，没有则向上一级作用域寻找。直到全局作用域，没找到就报错
  - 在函数中访问全局的变量可以使用window对象
  - 在函数作用域中也有声明提前，使用var和function都会声明提前
  - 在函数作用域中不使用var声明的变量都会称为全局变量
  - 定义形参相当于在函数作用域中声明了变量


#### 变量的声明提前
使用var关键字声明的变量，会在所有的代码执行前被声明（但是不会被赋值）。但是如果声明变量时不使用var关键字，变量不会声明提前。

函数的声明提前
- 使用函数声明创建的函数`function fun(){}`，会在所有的代码执行之前就被创建，我们可以在函数声明前调用函数。
- 使用函数表达式创建的函数`var fun = function(){}`不会声明提前

#### debug
- 断点调试
- 监控

#### this
解析器（浏览器）在调用函数时，每次都会向函数内部传递进一个隐含的参数，这个隐含的的参数就是this。
- this指向一个对象，这个对象我们称为函数的执行上下文对象
- 根据函数的调用的方式不同，this会指向不同的对象
- 以函数的形式调用时，this永远都是window
- 以方法的形式调用时，this就是调用这个方法的对象
- 以构造函数的形式调用时，this就是实例，即`var per = new Penson();`的`per`
- 

#### 工厂模式创建对象
使用工厂方法创建对象，通过该方法可以大批量创建对象.
- 创建一个函数
- 函数里创建一个新的对象
- 对象里添加属性
- 将新的对象通过return作为函数值返回
- 从外面传递参数

这种方法使用的构造函数都是Object，所以创建的对象都是Object这个类型，就导致我们无法区分多种不同类型的对象。

#### 构造函数创建对象
- 创建一个构造函数，专门创建Person对象(Penson类)
- 构造函数就是一个普通的函数，创建方式和普通函数没什么区别
- 不同的是构造函数习惯首字母大写
- 构造函数和普通函数的区别就是调用的方式不同
- 普通函数直接调用，构造函数需要使用new关键字调用`var per = new Penson;`
- 使用同一类构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类(Person类)，创建的对象称为该类的实例，或者该构造函数的实例。`per是Person类的实例`

构造函数的执行流程：
- 立即创建一个新的对象
- 将新建的对象设置为函数的this，在构造函数中可以使用this来引用新建的对象
- 逐行执行函数中的代码
- 将新建的对象作为返回值返回

通过instanceof可以检查一个对象是否是一个类的实例
- `对象 instanceof 构造函数`
- 是则返回true，不是则返回false

所有的对象都是Object构造函数的实例

将函数定义在全局作用域中，会污染全局作用域的命名空间，也很不安全。

#### 原型(prototype)
创建的每一个函数，解析器都会向函数中添加一个prototype属性，这个属性对应一个对象，这个对象就是原型对象。
- 如果函数作为普通函数调用prototype没有任何作用
- 当函数作为构造函数调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象。我们可以通过__proto__来访问该属性
- 原型对象就相当于一个公共的区域，所有同一类的实例都能访问到这个对象
- 可以将对象的共有属性，统一设置到原型对象中
- 当我们访问对象的属性或者方法时，会先在对象自身中寻找，有就使用，没有则会在原型对象中寻找，