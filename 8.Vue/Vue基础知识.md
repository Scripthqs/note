# Vue基础知识

## Vue概述

Vue(Vue.js)是一套用于构建用户界面的渐进式框架。

渐进式：

- 可以使用Vue对一个项目的某一个页面进行搭建，对之前使用JQuery或者原生JS的页面进行重构。
- Vue全家桶：Core + Vue-router + Vuex

Vue的核心概念：数据驱动，避免手动操作DOM元素。可以让前端开发者有更多的时间关注数据的业务逻辑，而不是关心DOM是如何渲染的。

### 框架和库

框架

- 一套完整的解决方案。功能完善，但是对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。
- Vue和React

库（插件）：

- 只是提供某个小功能。对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其他库实现需求。
- jQuery

### Vue的特点和高级功能：（开发时再慢慢体会）

特点：

- 模板渲染
- 响应式的更新机制：数据变化后，视图自动刷新
- 渐进式框架
- 组件化、模块化
- 轻量，占用内存小

高级功能：

- 解耦试图和数据
- 可复用的组件
- 前端路由技术
- 状态管理
- 虚拟DOM

具备HTML、CSS、JavaScript基础即可学习Vue。

## Vue.js安装

Vue.js分为开发版本和生产版本。

- 直接CDN引入
  - 通过script标签属性src引入文件的**绝对路径**。
  - 用户在读取网页内容的时候，就会去CND服务器中下载所需的文件，而不是在你的服务器里捞。
- 直接在官网下载所需版本的文件
  - 将文件复制到项目文件夹
  - 通过script标签属性src引入文件的**相对路径**。
- 通过NPM安装
  - NPM是Node默认的模块管理器，是命令行下的一个软件，用来安装和管理Node模块。
  - NPM不需要单独安装，在默认安装Node的时候，会连带一起安装NPM。
  - `$ npm install vue`安装最新稳定版

### Vue.js介绍

- 以前使用的编程范式，是命令式编程
- 使用Vue的编程范式，是声明式编程。

使用构造函数的方式，传一个对象`{}`作为参数。

- `{}`包含`el`属性：该属性决定这个Vue对象挂载到哪个元素
- `{}`包含了`data`属性，该属性通常会存储一些数据
  - 这些数据可以自定义
  - 也可以是从服务器加载的
- `{}`包含了`methods`属性，该属性用于在Vue中定义新的方法

- `v-for`循环
- `v-on`监听事件
  - `v-on:click`可以写成`@click`
- Vue的实例中，如果想要获取data里的属性、methods里面的方法，可以通过this来访问。
- this指向的是Vue的实例对象。

### MVVM模式

- `Model`
  - 数据层
  - 可以是自已定义的数据，也可以来自于服务器在网络请求的数据
  - 可定义数据修改和操作的业务逻辑 对应JS对象
- `View`
  - 用户看到的视图层
  - 在前端开发中，通常就是DOM层
  - 主要作用是给用户展示各种信息
- `view Model`
  - 视图模型层
  - 是View和Model沟通的桥梁
  - 一方面实现了`Data Bindings`（数据绑定），将Model的改变实时的反应到View
  - 另一方面它实现了`DOM Listener`（DOM 监听），当DOM发生一些事件（点击、滚动、touch等）时，可以监听到，并在需要的情况下改变对应的Data。
  - 负责业务逻辑的处理（比如Ajax请求），对数据进行加工后交给视图展示 同步连接V和M的对象

### 计数器中的MVVM

- `h1、button`标签就是`View`，就是DOM
- `data`这个对象的属性值就是`Model`，就是我们抽离出来的obj
- `new Vue()`就是`View Model`，我们创建的Vue实例

工作流程：

- `View Model`通过`Data Bindings`让obj的数据实时在DOM中显示。
- View Model`通过`DOM Listener`来监听`methods`中的操作，来改变obj中的数据。

好处：

- Vue可以帮助我们完成Vue Model层任务，避免手动操作DOM元素，让前端开发者有更多的时间去关注数据的业务逻辑处理。

### 创建Vue实例传入的options

最基础的options

- el
  - 类型：string | HTMLElement
  - 决定之后的Vue实例会管理哪个DOM
- data
  - 类型：Object | Function（组件当中时，data必须是函数）
  - Vue实例对应的数据类型
- methods
  - 类型：{[key:string]:Function}
  - 定义属于Vue的一些方法，可以在其他地方调用，也可以在指令中调用
- Vue的生命周期函数(钩子)

生命周期指从诞生到消亡的整个过程。

- `new Vue`
- `hook`钩子，生命周期函数又称为钩子函数。

方法和函数的区别：

- 方法（method）：对象中的函数是方法。
- 函数（function）：函数是一个具体特定功能的对象。

### 代码规范

- `=`两边各一个空格
- 缩进2个空格可能比缩进4个空格更合理

## 模板语法

Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。

### 插值表达式{{}}

- Mustache语法（也就是双大括号）
- 数据绑定最常见的形式就是使用双大括号的文本插值
- 插值处的内容都会自动更新
- `{{}}`之间可以使用表达式，比如复杂的3元表达式

### v-once

- 当加上这个指令时，不会随着数据改变自动更新

### v-html

- `v-html="msg"`可以将msg解析成html元素
- 使用v-html渲染数据可能会非常危险，因为它很容易导致XSS（跨站脚本）攻击
- 使用的时候请谨慎，能够使用{{}}或者v-text实现的不要使用v-html

### v-text

- `v-text="msg"`可以将一个变量的值渲染到指定的元素中
- `v-text`会覆盖元素中原本的内容
- `v-text`没有闪烁的问题，因为它是放在属性里的

### v-pre

- 将插值表达式原封不动的显示

### v-cloak

- `v-cloak`保持和元素实例的关联，直到结束编译自动消失
- 和CSS 规则一起用的时候，能够解决差值表达式闪烁的问题
- 即可以隐藏未编译的标签直到实例准备完毕）

````js
<style>
    [v-cloak]{
        display:none;
    }
</style>
````

## v-bind属性绑定机制

### v-bind绑定基本属性

基本属性：`src`和`href`属性

- `v-bind`：动态绑定用于绑定属性
- `<img v-bind:src="img动态地址">`
- v-bind的属性值里，可以写合法的 js 表达式
- Vue语法糖：可以省略`v-bind`，只写`:`

### v-bind动态绑定`class`属性

动态绑定class的属性的两种方式：

- 对象语法：
  - 对象的语法含义是：class后面跟一个对象
  - `:class="{类名：boolean}"`
  - 该布尔值动态可以写成`data`的属性
  - 该class属性可以写成`methods`方法，注意属性值要写`this`
  - 调用methods方法时，需要加上`()`
- 数组语法：
  - 数组语法的含义是：在class后面跟一个数组
  - `:class="[]"`
  - 使用较少

对象语法和数组语法，都能够和普通的class类共存。

### v-bind动态绑定`style`属性

- 为什么要动态绑定样式？
  - 学习组件化开发时，组件封装好后是可以复用的。
- `:style="{key(属性名):value(属性值)}"
  - 属性名使用驼峰命名法或者下划线
  - 属性值不加引号表示变量
  - value值可以来自data中的属性
- 也分为对象语法和数组语法

## computed计算属性

定义一个函数，return函数的返回值。

- 字符串拼接
- 返回函数的计算结果，计算属性的函数写在computed中
- 使用计算属性时是属性名，而不是调用函数的形式

### 计算属性的setter和getter

`computed`计算属性中，计算属性默认只有 getter，所以一般都是简写的，所有调用都不加括号

### 计算属性的缓存

计算属性虽然和定义方法得到的最终结果是一样的，但是计算数学是基于它们的响应式依赖进行缓存的。所以多使用计算属性少使用方法。

## v-on属性事件监听处理

可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码

### v-on事件绑定机制

- `v-on:click`绑定单击响应函数
- `v-on:`可以简写为`@`
- 可以绑定click keydown keyup mousedown mouseover ...等事件

### v-on参数问题

- 如果该方法不需要额外的参数，那么该方法后的`()`可以省略
- 在事件定义时，写方法省略了小括号，但是方法本身是需要一个参数的，这个时候Vue会默认将浏览器生成的event事件对象作为参数传入到方法。
- 方法定义时，除了event对象，同时又需要其他参数，使用`$event`获取浏览器的event事件

### v-on修饰符

- `.stop`阻止冒泡
- `.prevent`阻止默认事件（默认行为）
- `@keyup.enter`检测回车键按下时
- `.once`事件只触发一次
- 一个事件，允许同时使用多个事件修饰符

## v-if条件判断

- `v-if` `v-else``v-else-if`条件判断
- Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染
- Vue 提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key attribute 即可

### v-if和v-show

- `v-if`当条件为false时，包含v-if指令的元素，根本不会存在在dom中
- `v-show`当条件为false时，只是在元素中添加一个行内样式`display:none`
  
如何选择？

- 当需要在显示和隐藏之间切换很频繁时，使用v-show
- 当只有一次切换时，使用v-if
- 实际开发中使用v-if更多，很多情况下需要根据服务器传的数据决定要不要渲染

## v-for列表渲染

- `v-for`可以变量对象和数组
- 在遍历数组时，第一个值是属性值value，第二个是索引值index
- 在遍历对象时，如果只获取一个值，是value值，第二个值是key值，第三个值是index值
- 官方建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。
- 插入数组时，没有key会很笨，有key在复用时，会对比key值，key需要保证一个唯一item.id
- key的作用主要是为了高效的更新虚拟DOM

### 数组更新检测

数组中的元素发生变化时，界面会自动刷新，因为数据是响应式的。

- `.push()`在数组最后面添加一个元素
- `pop()`删除数组最后一个元素
- `shift()`删除数组第一个元素
- `unshift()`在数组最前面添加元素
- `splice(开始元素的索引，需要删除几个元素，"添加的元素")`删除/插入/替换，删除0个时即可替换和插入
- `sort()`排序
- `reverse()`反转

以上的方法式响应式的，**通过索引修改数组中的元素不是响应式的**

- 可以通过`Vue.set(要修改的对象，索引值，修改后的值)`解决
- 或者`splice()`方法解决

### 过滤器

filter过滤器，可以用在两个地方：双花括号插值和 v-bind 表达式

## v-model表单输入绑定

### 高阶函数

- `filter` 过滤 filter中的回调函数有一个要求，必须返回boolean值
  - true 函数内部会自动将这次回调的n加到新的数组
  - false 函数内部会过滤掉这次的n
- `map` 映射
- `reduce` 对数组中所有元素进行汇总

### v-model指令

v-model指令配合表单使用，实现双向绑定

- `v-model`结合单选框`radio`使用
- `v-model`结合多选框使用`checkbox`使用
- `v-model`结合select使用，分单选和多选，需要绑定在select标签上，不能绑定在options上
- `v-model`值绑定 就是v-bind动态绑定
  - 世界开发中，有些input值是从网络中获取或定义在data中的
  - 所以可以通过v-bind:value动态的value绑定值
- `v-model`修饰符
  - `.lazy`默认情况下，data中的数据会和input中的数据同步变化，`.lazy`修饰符可以在数据失去焦点或者回车时才更新
  - `.number`输入框中输入元素的值总会返回字符串类型，`.number`修饰符可以将用户的输入值转为数值类型
  - `.trim`自动过滤用户输入的首尾空白字符

## components组件化开发

### 什么是组件化？

将复杂问题拆分成多个可以处理的小问题，再将其放在整体中。

在开发中，将一个页面拆分成一个个小的、可复用的组件，每个组件完成属于自己这部分的独立功能，从而方便整个页面的管理和维护。

### 注册组件如何使用

1. 创建组件构造器 调用`Vue.extend()`方法
2. 注册组件 调用`Vue.component()`方法
3. 使用组件 在Vue实例的作用范围内使用组件

### 全局组件和局部组件

- 全局组件在script标签下注册，可以在多个Vue的实例下面使用
- 局部组件在Vue实例中注册，开发时一般是局部组件

### 父组件和子组件

- 在一个组件的components下面注册另一个组件，另一个组件就是子组件
- 最开始的Vue实例可以看成root组件

组件语法糖注册：可以省略创建组件构造器`Vue.extend()`步骤，直接注册，使用`Vue.component('cpn',{template:})`，使用一个对象来代替。

### 模板的分离写法

- 写在的`<script>`中，需要一个id
- 写在的`<template>`中，需要一个id

注意：组件中`<template>`标签中必须要包括一个根，要写个`div`或者块级元素，不然会报错

### 组件中的变量放在什么位置？

- 组件的变量不能放在Vue实例中的data中
- 组件是一个单独功能的模块封装
- 组件不可以访问Vue实例中的数据
- Vue组件应该有自己保存数据的地方

组件的数据存放的位置：

- 组件对象也有一个data属性，可以是methods属性
- 这个data属性必须是一个函数`data(){}`
- 这个函数返回一个对象，对象内部保存数据`data(){return {}}`

为什么data必须是一个函数？

如果组件中的data中的是一个对象，到时候创建的组件实例都会指向一个相同的对象。而组件不应该相互影响。

### 父子组件的通信

子组件不能引用父组件和Vue实例的数据。但在实际开发中，往往一些数据需要从上层传递到下层。

- 在一个页面中，我们从服务器请求到很多数据
- 其中一部分数据，并非是整个页面的大组件来展示的，而是需要下面的子组件进行展示
- 这时，不需要让子组件再次发送一个网络请求，而是直接让大组件（父组件）将数据传递给小组件（子组件）

如何进行父子组件的通信

- 父传子：通过props像子组件传递数据properties
- 子传父：通过事件向父组件发送消息`$emit()`

props基本使用

1. 字符串数组，数组中的字符串就是传递时的名称
2. 对象，对象可以设置传递时的类型，可以设置默认值，也可以设置
   - type 类型
   - default 默认值 默认值时对象时，fefault必须是函数
   - required 必需的，true或者false

### 父子组件的访问方式

当需要父组件直接访问子组件，或者子组件直接访问父组件，或者子组件访问根组件

- 父组件访问子组件：使用`$children`或者`$refs`
- 子组件访问父组件；使用`$parent`

- `$children`是一个数组类型，它包含所有的子组件对象
- `$refs`是一个对象类型，默认是一个空的对象，必须在组件上加一个`ref='aaa'`的属性才能读取

子组件访问父组件使用`$parent`，使用`$root`可以直接访问根组件

### 插槽

`slot`插槽

- 在组件中定义一个`<slot></slot>`标签即可，
- 还可以设置默认值`<slot><h2>标题</h2></slot>`
- 使用组件时，多个标签会全部作为替换元素

编译作用域：父模板的所有东西都会在父级作用域内编译，子组件模板的所有东西都会在子级作用域内编译。

作用域插槽：父组件替换插槽的标签，但是内容由子组件来提供

- v-slot:name
- v-slot="socpe"

## 模块化开发

### 为什么使用模块化

- 解决全局变量命名冲突问题
- 解决js文件必须按照一定顺序引入的问题

### 如何使用模块化

- 使用匿名函数，还需要使用一个模块作为出口，暴露函数里面的变量
- 在匿名函数中定义一个对象
- 给对象添加各种需要暴露的属性和方法
- 最后将这个对象返回，并且在外面使用一个MoudleA接收

### 常见的模块化规范

- 模块化已经有很多既有的规范和对应的实现方案，常见的模块化规范：
- CommonJS
- AMD
- CMD
- ES6的Modules

模块化两个核心：导出和导入

CommonJS模块化的导出和导入

- 导出：`module.exports = {}`
- 导入：`let {flag,sum} = require('aaa.js')`

ES6模块化实现

`<script type="module"></script>`使用type可以让模块中的变量在单独的空间，此时，可以通过import命令加载这个对应的模块

方式1：

- `export`使用`export{需要导出的变量}`
- `import`使用`import {需要导入的变量} from "./aaa.js"`

方式2：

- `export let 变量 = 变量值`
- 导入方式一样

方式3：导出函数/类

- `export function fn1(){}`
- `export class Person{}`

方式4：

- `export default`
- 导入时，可以根据需要自主命名
- `export default`在同一模块中，不允许同时存在多个

如果需要导入的变量很多时，使用：

- `import * as aaa from "./aaa.js"`
